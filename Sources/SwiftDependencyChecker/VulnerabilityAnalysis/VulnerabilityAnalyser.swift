//
//  VulnerabilityAnalyser.swift
//  DependencyChecker
//
//  Created by Kristiina Rahkema on 02.01.2022.
//

import Foundation

class VulnerabilityAnalyser {
    var vulnerabilities: VulnerabilityDictionary
    var url: URL
    var folder: URL
    var changed = false
    let settings: Settings
    
    init(settings: Settings) {
        self.folder = settings.homeFolder
        self.url = self.folder.appendingPathComponent("vulnerabilities.json")
        
        if let data = try? Data(contentsOf: url) {
            let decoder = JSONDecoder()
            if let decoded = try? decoder.decode(VulnerabilityDictionary.self, from: data) {
                vulnerabilities = decoded
            } else {
                vulnerabilities = VulnerabilityDictionary(lastUpdated: Date())
            }
        } else {
            vulnerabilities = VulnerabilityDictionary(lastUpdated: Date())
        }
        self.settings = settings
    }
    
    func shouldUpdate(data: VulnerabilityData) -> Bool{
        Logger.log(.info, "[i] Vulnerability data last updated: \(data.lastUpdated)")
        
        let timeInterval = self.settings.vulnerabilityTimeInterval 
        // check if time since last updated is larger than the allowed timeinterval for updates
        if data.lastUpdated.timeIntervalSinceNow * -1 > timeInterval {
            Logger.log(.info, "[i] Will update vulnerability data")
            return true
        }
        
        Logger.log(.debug, "[i] No update for vulnerability data")
        return false
    }
    
    deinit {
        if changed {
            save()
        }
    }
    
    func save() {
        self.checkFolder()
        
        let encoder = JSONEncoder()
        if let encoded = try? encoder.encode(self.vulnerabilities) {
            do {
                try encoded.write(to: url)
            } catch {
                Logger.log(.error, "Could not save vulnerabilities")
            }
        }
    }
    
    func checkFolder() {
        if !FileManager.default.fileExists(atPath: self.folder.absoluteString) {
            do {
                try FileManager.default.createDirectory(at: self.folder, withIntermediateDirectories: true, attributes: nil)
            } catch {
                Logger.log(.error, "Could not create folder: \(self.folder)")
            }
        }
    }
    
    func query(for cpe: String) -> [CVEData] {
        var cveList: [CVEData] = []
        
        let group = DispatchGroup()
        group.enter()
        
        Logger.log(.debug, "[*] Querying data for cpe: \(cpe) ...")
        if let url = URL(string: "https://services.nvd.nist.gov/rest/json/cves/1.0?cpeMatchString=\(cpe)&resultsPerPage=2000") {
            
            // program waits 6 seconds between requests so that the NVD API limit on 10 requests per minute is not exceeded
            sleep(6)
            
        URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) -> Void in
            defer { group.leave() }
            Logger.log(.debug, "[i] Successful response")
            //TODO: handle response code, for example if it is 503
            // response shema: https://csrc.nist.gov/schema/nvd/feed/1.1/nvd_cve_feed_json_1.1.schema
            if let data = data {
                do {
                    if let json = try JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any] {
                        if let resultsPerPage = json["resultsPerPage"] as? Int, let totalResults = json["totalResults"] as? Int {
                            
                            if totalResults > 0 {
                                if let result = json["result"] as? [String: Any] {
                                    
                                    if let cves = result["CVE_Items"] as? [[String: Any]] {
                                        for cve in cves {
                                            var cveData = CVEData(fromJson: cve)
                                            
                                            cveList.append(cveData)
                                            
                                        }
                                        /*
                                        for cve in cves {
                                            if let cpeuri = cpe["cpe23Uri"] as? String {
                                                Logger.log("[i] cpe: \(cpeuri)")
                                                
                                                if cpeuri.contains(projectName) {
                                                    addLineToLogFile(line: "cpe: \(cpeuri)")
                                                } else {
                                                    continue
                                                }
                                            }
                                        }
     */
                                    } else {
                                        Logger.log(.error, "[!] CVE object not found")
                                    }
                                }
                              //  break
                            }
                        }
                    } else {
                        Logger.log(.error, "[!] No json.")
                    }
                } catch {
                    Logger.log(.error, "[!] Failed parsing json.")
                }
            }
        }).resume()
        group.wait()
       // break
        }
        
        return cveList
    }
    
    func queryVulnerabilitiesFor(cpe: String) -> [CVEData] {
        Logger.log(.debug, "[*] Finding vulnerabilities for cpe: \(cpe)")
        if let existingCVEData = self.vulnerabilities.dictionary[cpe] {
            if self.shouldUpdate(data: existingCVEData) {
                Logger.log(.debug, "[i] Existing data, but should update.")
                let cveList = query(for: cpe)
                existingCVEData.vulnerabilities = cveList
                existingCVEData.lastUpdated = Date()
                self.vulnerabilities.dictionary[cpe] = existingCVEData
                self.changed = true
                return cveList
            } else {
                Logger.log(.debug, "[i] Found existing data")
                let cveList = existingCVEData.vulnerabilities
                return cveList
            }
        } else {
            Logger.log(.debug, "[i] No existing data found.")
            let cveList = query(for: cpe)
            self.vulnerabilities.dictionary[cpe] = VulnerabilityData(vulnerabilities: cveList)
            self.changed = true
            return cveList
        }
    }
}

class VulnerabilityDictionary: Codable {
    var dictionary: [String: VulnerabilityData]
    
    init(lastUpdated: Date) {
        self.dictionary = [:]
    }
}

class VulnerabilityData: Codable {
    var lastUpdated: Date
    var vulnerabilities: [CVEData]
    
    init(vulnerabilities: [CVEData]) {
        self.lastUpdated = Date()
        self.vulnerabilities = vulnerabilities
    }
}

class CVEData: Codable {
    var publishedDate: String?
    var lastModifiedDate: String?
    
    var configuration: Configuration?
    var impact: Impact?
    var cve: CVE? // required value
    
    init(fromJson: [String: Any]) {
        self.publishedDate = fromJson["publishedDate"] as? String
        self.lastModifiedDate = fromJson["lastModifiedDate"] as? String
        
        if let configuration = fromJson["configurations"] as? [String: Any] {
            if let nodes = configuration["nodes"] as? [[String: Any]] {
                self.configuration = Configuration(fromJson: nodes)
            }
        }
        
        if let impact = fromJson["impact"] as? [String: Any] {
            self.impact = Impact(fromJson: impact)
        }
        
        if let cve = fromJson["cve"] as? [String: Any] {
            self.cve = CVE(fromJson: cve)
        }
    }
}

class CVE: Codable {
    var description: String? // required
    var problemType: String? // required
    var references: [Reference] = [] // required
    var cveId: String? // required
    
    init(fromJson: [String: Any]) {
        if let metaData = fromJson["CVE_data_meta"] as? [String: Any] {
            if let id = metaData["ID"] as? String {
                self.cveId = id
            }
        }
        
        if let descriptionObject = fromJson["description"] as? [String:Any] {
            self.description = ""
            if let descriptionData = descriptionObject["description_data"] as? [[String: Any]] {
                for description in descriptionData {
                    if let language = description["lang"] as? String, let value = description["value"] as? String {
                        if self.description?.count == 0 {
                            self.description = "\(language): \(value)"
                        } else {
                            self.description = "\(self.description), \(language): \(value)"
                        }
                    }
                }
            }
        }
        
        if let problemTypeObject = fromJson["problemtype"] as? [String: Any] {
            self.problemType = ""
            if let problemTypeData = problemTypeObject["problemtype_data"] as? [[String: Any]] {
                for problemType in problemTypeData {
                    if let problemTypeDescriptions = problemType["description"] as? [[String: Any]] {
                        for problemTypeDescription in problemTypeDescriptions {
                            if let language = problemTypeDescription["lang"] as? String, let value = problemTypeDescription["value"] as? String {
                                if self.problemType?.count == 0 {
                                    self.problemType = "\(language): \(value)"
                                } else {
                                    self.problemType = "\(self.problemType), \(language): \(value)"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        if let referencesObject = fromJson["references"] as? [String: Any] {
            self.references = []
            if let referencesData = referencesObject["reference_data"] as? [[String: Any]] {
                for reference in referencesData {
                    self.references.append(Reference(fromJson: reference))
                }
            }
        }
        /*
         also exists:
         #affects
         #CVE_data_meta required
         #data_type required
         #data_version required
         #data_fromat required
         */
    }
    
}

class Reference: Codable {
    var name: String?
    var refSource: String?
    var tags: [String]
    var url: String? // required
    
    init(fromJson: [String: Any]) {
        self.name = fromJson["name"] as? String
        self.refSource = fromJson["refsource"] as? String
        self.url = fromJson["url"] as? String
        
        if let tags = fromJson["tags"] as? [String] {
            self.tags = tags
        } else {
            self.tags = []
        }
    }
}

class Configuration: Codable {
    // also has
    // CVE_data_version, required
    var nodes: [Node] = []
    
    init(fromJson: [[String: Any]]) {
        self.nodes = []
        for node in fromJson {
            nodes.append(Node(fromJson: node))
        }
    }
    
    var affectedVersions: [CPEMatch] {
        var list: [CPEMatch] = []
        for node in nodes {
            list.append(contentsOf: node.affectedVersions)
        }
        return list
    }
}

/*
 nodes =     (
                 {
             children =             (
             );
             "cpe_match" =             (
                                 {
                     cpe23Uri = "cpe:2.3:a:atlassian:connect_spring_boot:*:*:*:*:*:*:*:*";
                     "cpe_name" =                     (
                     );
                     versionEndExcluding = "2.1.3";
                     versionStartIncluding = "1.1.0";
                     vulnerable = 1;
                 }
             );
             operator = OR;
         }
     );
 */

class Node: Codable {
    var children: [Node] = []
    var cpeMatch: [CPEMatch] = []
    var operatorString: String //TODO: make operator as enum?
    // also
    // negate
    //
    
    var affectedVersions: [CPEMatch] {
        var list: [CPEMatch] = []
        for node in children {
            list.append(contentsOf: node.affectedVersions)
        }
        
        for cpeMatch in self.cpeMatch {
            list.append(cpeMatch)
        }
        
        return list
    }
    
    init(fromJson: [String: Any]) {
        if let children = fromJson["children"] as? [[String:Any]] {
            for child in children {
                self.children.append(Node(fromJson: child))
            }
        }
        
        if let cpeMatch = fromJson["cpe_match"] as? [[String:Any]] {
            for match in cpeMatch {
                self.cpeMatch.append(CPEMatch(fromJson: match))
            }
        }
        
        if let operatorString = fromJson["operator"] as? String {
            self.operatorString = operatorString
        } else {
            self.operatorString = "--" // should not happen
        }
    }
}

class CPEMatch: Codable {
    /*
     "cpe_match" =             (
                                     {
                         cpe23Uri = "cpe:2.3:a:atlassian:connect_spring_boot:*:*:*:*:*:*:*:*";
                         "cpe_name" =                     (
                         );
                         versionEndExcluding = "2.1.3";
                         versionStartIncluding = "1.1.0";
                         vulnerable = 1;
                     }
                 );
     */
    var originalcpeString: String
    var cpeString: String // required
    var versionEndExcluding: String?
    var versionEndIncluding: String?
    var versionStartIncluding: String?
    var versionStartExcluding: String?
    var exactVersion: String?
    var vulnerable: Bool // required
    
    var versionString: String {
        var string = ""
        if let versionEndExcluding = versionEndExcluding {
            string += "endExcluding: \(versionEndExcluding) "
        }
        
        if let versionEndIncluding = versionEndIncluding {
            string += "endIncluding: \(versionEndIncluding) "
        }
        
        if let versionStartExcluding = versionStartExcluding {
            string += "startExcluding: \(versionStartExcluding) "
        }
        
        if let versionStartIncluding = versionStartIncluding {
            string += "startIncluding: \(versionStartIncluding) "
        }
        
        return string 
    }
    // other
    // cpe22Uri
    // cpe_name (array of cpe names)
    
    init(fromJson: [String: Any]) {
        if let cpe23Uri = fromJson["cpe23Uri"] as? String {
            self.originalcpeString = cpe23Uri
            var components = cpe23Uri.split(separator: ":")
            // cpe:2.3:a:libevent_project:libevent:*:beta:*:*:*:*:*:*
            //cpe:2.3:a:google:protobuf:2.4.1:*:*:*:*:*:*:*
            
            let potentialVersion = components[5]
            if potentialVersion != "" && potentialVersion != "*" && potentialVersion != "-" {
                self.exactVersion = String(potentialVersion)
            }
            
            components[5] = "" // version number if specified
            components[6] = "" // if beta specified
        
            self.cpeString = components.joined(separator: ":")
        } else {
            self.cpeString = "Not found" // should never happen
            self.originalcpeString = "Not found" // should never happen
        }
        
        if let vulnerable = fromJson["vulnerable"] as? Bool {
            self.vulnerable = vulnerable
        } else {
            self.vulnerable = false // should never happen
        }
        
        if let versionEndExcluding = fromJson["versionEndExcluding"] as? String {
            self.versionEndExcluding = versionEndExcluding
        }
        
        if let versionEndIncluding = fromJson["versionEndIncluding"] as? String {
            self.versionEndIncluding = versionEndIncluding
        }
        
        if let versionStartIncluding = fromJson["versionStartIncluding"] as? String {
            self.versionStartIncluding = versionStartIncluding
        }
        
        if let versionStartExcluding = fromJson["versionStartExcluding"] as? String {
            self.versionStartExcluding = versionStartExcluding
        }
    }
}

class Impact: Codable {
    var baseMetricV3: BaseMetric?
    var baseMetricV2: BaseMetric?
    
    init(fromJson: [String: Any]) {
        if let baseMetricV2 = fromJson["baseMetricV2"] as? [String: Any] {
            let parsedV2 = BaseMetric(fromV2Json: baseMetricV2)
            self.baseMetricV2 = parsedV2
        }
        
        if let baseMetricV3 = fromJson["baseMetricV3"] as? [String: Any] {
            let parsedV3 = BaseMetric(fromV3Json: baseMetricV3)
            self.baseMetricV3 = parsedV3
        }
    }
}

class BaseMetric: Codable {
    var attackComplexity: String?        //v3,   v2 (accessComplexity)
    var attackVector: String?            //v3,   v2
    var authentication: String?          //      v2
    var availabilityImpact: String?      //v3,   v2
    var baseScore: Float?               //v3,   v2
    var baseSeverity: String?            //v3,   v2 (severity)
    var confidentialityImpact: String?   //v3,   v2
    var integrityImpact: String?         //v3,   v2
    var privilegesRequired: String?      //v3    (== authentication??)
    var scope: String?                   //v3
    var userInteractionRequired: String? //v3 (userInteraction) ,   v2
    var vectorString: String?            //v3,   v2
    var exploitabilityScore: Float?     //v3,   v2
    var impactScore: Float?             //v3,   v2
    var version: MetricVersion          //
    var obtainAllPrivilege: Bool?        //      v2
    var obtainOtherPrivilege: Bool?      //      v2
    var obtainUserPrivilege: Bool?       //      v2
    
    enum MetricVersion: Int, Codable {
        case V2 = 2
        case V3 = 3
    }
    
    init(fromV3Json: [String: Any]) {
        /*
         baseMetricV3 =     {
                cvssV3 =         {
                    attackComplexity = LOW;
                    attackVector = NETWORK;
                    availabilityImpact = NONE;
                    baseScore = "7.1";
                    baseSeverity = HIGH;
                    confidentialityImpact = LOW;
                    integrityImpact = HIGH;
                    privilegesRequired = NONE;
                    scope = UNCHANGED;
                    userInteraction = REQUIRED;
                    vectorString = "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:N";
                    version = "3.1";
                };
                exploitabilityScore = "2.8";
                impactScore = "4.2";
            };
         */
        
        if let cvssV3 = fromV3Json["cvssV3"] as? [String: Any] {
            if let attackComplexity = cvssV3["attackComplexity"] as? String {
                self.attackComplexity = attackComplexity
            }
            
            if let attackVector = cvssV3["attackVector"] as? String {
                self.attackVector = attackVector
            }
            
            if let availabilityImpact = cvssV3["availabilityImpact"] as? String {
                self.availabilityImpact = availabilityImpact
            }
            
            if let baseScore = cvssV3["baseScore"] as? Float {
                self.baseScore = baseScore
            }
            
            if let baseSeverity = cvssV3["baseSeverity"] as? String {
                self.baseSeverity = baseSeverity
            }
            
            if let confidentialityImpact = cvssV3["confidentialityImpact"] as? String {
                self.confidentialityImpact = confidentialityImpact
            }
            
            if let integrityImpact = cvssV3["integrityImpact"] as? String {
                self.integrityImpact = integrityImpact
            }
            
            if let privilegesRequired = cvssV3["privilegesRequired"] as? String {
                self.privilegesRequired = privilegesRequired
            }
            
            if let scope = cvssV3["scope"] as? String {
                self.scope = scope
            }
            
            if let userInteraction = cvssV3["userInteraction"] as? String {
                self.userInteractionRequired = userInteraction
            }
            
            if let vectorString = cvssV3["vectorString"] as? String {
                self.vectorString = vectorString
            }
        }
        
        if let exploitabilityScore = fromV3Json["exploitabilityScore"] as? Float {
            self.exploitabilityScore = exploitabilityScore
        }
        
        if let impactScore = fromV3Json["impactScore"] as? Float {
            self.impactScore = impactScore
        }
        
        self.version = .V3
    }
    
    init(fromV2Json: [String: Any]) {
        /*
         baseMetricV2 =     {
             acInsufInfo = 0;
             cvssV2 =         {
                 accessComplexity = LOW;
                 accessVector = NETWORK;
                 authentication = NONE;
                 availabilityImpact = COMPLETE;
                 baseScore = 10;
                 confidentialityImpact = COMPLETE;
                 integrityImpact = COMPLETE;
                 vectorString = "AV:N/AC:L/Au:N/C:C/I:C/A:C";
                 version = "2.0";
             };
             exploitabilityScore = 10;
             impactScore = 10;
             obtainAllPrivilege = 0;
             obtainOtherPrivilege = 0;
             obtainUserPrivilege = 0;
             severity = HIGH;
             userInteractionRequired = 0;
         };
         */
        
        if let cvssV2 = fromV2Json["cvssV2"] as? [String: Any] {
            if let accessComplexity = cvssV2["accessComplexity"] as? String {
                self.attackComplexity = accessComplexity
            }
            
            if let accessVector = cvssV2["accessVector"] as? String {
                self.attackVector = accessVector
            }
            
            if let authentication = cvssV2["authentication"] as? String {
                self.authentication = authentication
            }
            
            if let availabilityImpact = cvssV2["availabilityImpact"] as? String {
                self.availabilityImpact = availabilityImpact
            }
            
            if let baseScore = cvssV2["baseScore"] as? Float {
                self.baseScore = baseScore
            }
            
            if let confidentialityImpact = cvssV2["confidentialityImpact"] as? String {
                self.confidentialityImpact = confidentialityImpact
            }
            
            if let integrityImpact = cvssV2["integrityImpact"] as? String {
                self.integrityImpact = integrityImpact
            }
            
            if let vectorString = cvssV2["vectorString"] as? String {
                self.vectorString = vectorString
            }
        }
        
        if let exploitabilityScore = fromV2Json["exploitabilityScore"] as? Float {
            self.exploitabilityScore = exploitabilityScore
        }
        
        if let impactScore = fromV2Json["impactScore"] as? Float {
            self.impactScore = impactScore
        }
        
        if let obtainAllPrivilege = fromV2Json["obtainAllPrivilege"] as? Bool {
            self.obtainAllPrivilege = obtainAllPrivilege
        }
        
        if let obtainOtherPrivilege = fromV2Json["obtainOtherPrivilege"] as? Bool {
            self.obtainOtherPrivilege = obtainOtherPrivilege
        }
        
        if let obtainUserPrivilege = fromV2Json["obtainUserPrivilege"] as? Bool {
            self.obtainUserPrivilege = obtainUserPrivilege
        }
        
        if let severity = fromV2Json["severity"] as? String {
            self.baseSeverity = severity
        }
        
        if let userInteractionRequired = fromV2Json["userInteractionRequired"] as? Bool {
            self.userInteractionRequired = "\(userInteractionRequired)"
        }
        
        self.version = .V2
    }
}
